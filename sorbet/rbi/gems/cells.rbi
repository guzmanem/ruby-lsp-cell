# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: false
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/cells/all/cells.rbi
#
# cells-4.1.8

module Cell
end
module Cell::Caching
  def cache?(state, *args); end
  def cache_store; end
  def fetch_from_cache_for(key, options, &block); end
  def perform_caching?; end
  def render_state(state, *args); end
  def self.included(includer); end
  def state_cached?(state); end
end
module Cell::Caching::ClassMethods
  def cache(state, *args, &block); end
  def expand_cache_key(key); end
  def expire_cache_key_for(key, cache_store, *args); end
  def state_cache_key(state, key_parts = nil); end
end
module Cell::Prefixes
  def _prefixes; end
  def self.included(includer); end
end
module Cell::Prefixes::ClassMethods
  def _local_prefixes; end
  def _prefixes; end
  def inherit_views(parent); end
  def prefixes; end
end
class Cell::ViewModel
  def cell(name, model = nil, options = nil); end
  def context; end
  def initialize(model = nil, options = nil); end
  def model; end
  def normalize_options(options); end
  def options; end
  def output_buffer; end
  def self.build(*, **); end
  def self.cache_options; end
  def self.cache_options=(v); end
  def self.call(model = nil, options = nil, &block); end
  def self.class_from_cell_name(name); end
  def self.conditional_procs; end
  def self.conditional_procs=(v); end
  def self.controller_path; end
  def self.layout_name; end
  def self.layout_name=(v); end
  def self.property(*names); end
  def self.templates; end
  def self.version_procs; end
  def self.version_procs=(v); end
  def self.view_paths; end
  def self.view_paths=(v); end
  def setup!(model, options); end
  def state_for_implicit_render(options); end
  def to_s; end
  extend Cell::Abstract
  extend Cell::Caching::ClassMethods
  extend Cell::Prefixes::ClassMethods
  extend Cell::Util
  extend Cell::ViewModel::Helpers
  extend Cell::ViewModel::Layout::ClassMethods
  extend Uber::Delegates
  extend Uber::InheritableAttr
  extend Uber::InheritableAttr
  include Cell::Caching
  include Cell::Prefixes
  include Cell::ViewModel::Layout
  include Cell::ViewModel::ProcessOptions
  include Cell::ViewModel::Rendering
  include Cell::ViewModel::TemplateFor
end
module Cell::ViewModel::Layout
  def process_options!(options); end
  def render_layout(name, options, content); end
  def render_to_string(options, &block); end
  def self.included(base); end
  def with_layout(options, content); end
end
module Cell::ViewModel::Layout::ClassMethods
  def layout(name); end
end
module Cell::ViewModel::Layout::External
  def call(*); end
end
class Cell::Templates
  def [](prefixes, view, options); end
  def cache; end
  def create(prefix, view, options); end
  def find_template(prefixes, view, options); end
end
class Cell::Templates::Cache
  def fetch(prefixes, view); end
  def get(prefixes, view); end
  def initialize; end
  def store(prefix, view, template); end
end
module Cell::Abstract
  def abstract!; end
  def abstract?; end
end
module Cell::Util
  def util; end
end
class Cell::Util::Inflector
  def self.constant_for(name); end
  def self.underscore(constant); end
end
module Cell::ViewModel::Helpers
  def cell(name, *args, &block); end
end
class Cell::ViewModel::Context
  def self.[](options, context); end
end
module Cell::ViewModel::Rendering
  def call(state = nil, *args, &block); end
  def render(options = nil, &block); end
  def render_state(*args, &block); end
  def render_template(template, options, &block); end
  def render_to_string(options, &block); end
  def show(&block); end
end
class Cell::ViewModel::OutputBuffer < Array
  def <<(string); end
  def append=(string); end
  def encoding; end
  def safe_append=(string); end
  def to_s; end
end
module Cell::ViewModel::TemplateFor
  def find_template(options); end
  def template_for(prefixes, view, options); end
end
module Cell::ViewModel::ProcessOptions
  def process_options!(options); end
end
module Cell::SelfContained
  def self_contained!; end
end
module Cell::SelfContained::Prefixes
  def _local_prefixes; end
end
class Cell::Concept < Cell::ViewModel
  def concept(name, model = nil, options = nil); end
  def self.class_from_cell_name(name); end
  def self.controller_path; end
  extend Cell::SelfContained
  extend Cell::SelfContained::Prefixes
end
module Cell::ViewModel::Escaped
  def escape!(string); end
  def self.included(includer); end
end
module Cell::ViewModel::Escaped::Property
  def property(*names); end
end
module Cell::Builder
  def self.included(base); end
end
module Cell::Builder::ClassMethods
  def build(*args); end
end
class Cell::Collection
  def _deprecated_collection_join=(arg0); end
  def _deprecated_method=(arg0); end
  def collection_join; end
  def collection_join=(*args, **, &block); end
  def initialize(ary, options, cell_class); end
  def join(separator = nil, &block); end
  def method; end
  def method=(*args, **, &block); end
  def set_deprecated_options(options); end
  def to_s; end
  extend Gem::Deprecate
  include Cell::Collection::Call
  include Cell::Collection::Layout
end
module Cell::Collection::Call
  def call(state = nil); end
end
module Cell::Collection::Layout
  def call(*); end
end
class Cell::TemplateMissingError < RuntimeError
  def initialize(prefixes, view); end
end
