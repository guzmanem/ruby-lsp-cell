# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: strict
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/ruby-lsp/all/ruby-lsp.rbi
#
# ruby-lsp-0.23.24

module RubyLsp
end
class RubyLsp::Addon
  def activate(global_state, outgoing_queue); end
  def add_error(error); end
  def create_code_lens_listener(response_builder, uri, dispatcher); end
  def create_completion_listener(response_builder, node_context, dispatcher, uri); end
  def create_definition_listener(response_builder, uri, node_context, dispatcher); end
  def create_discover_tests_listener(response_builder, dispatcher, uri); end
  def create_document_symbol_listener(response_builder, dispatcher); end
  def create_hover_listener(response_builder, node_context, dispatcher); end
  def create_semantic_highlighting_listener(response_builder, dispatcher); end
  def deactivate; end
  def error?; end
  def errors_details; end
  def formatted_errors; end
  def handle_window_show_message_response(title); end
  def initialize; end
  def name; end
  def resolve_test_commands(items); end
  def self.addon_classes; end
  def self.addons; end
  def self.addons=(arg0); end
  def self.depend_on_ruby_lsp!(*version_constraints); end
  def self.file_watcher_addons; end
  def self.file_watcher_addons=(arg0); end
  def self.get(addon_name, *version_constraints); end
  def self.inherited(child_class); end
  def self.load_addons(global_state, outgoing_queue, include_project_addons: nil); end
  def self.unload_addons; end
  def version; end
end
class RubyLsp::Addon::AddonNotFoundError < StandardError
end
class RubyLsp::Addon::IncompatibleApiError < StandardError
end
class RubyLsp::BaseServer
  def fail_request_and_notify(id, message, type: nil); end
  def initialize(**options); end
  def new_worker; end
  def pop_response; end
  def process_message(message); end
  def push_message(message); end
  def run_shutdown; end
  def send_empty_response(id); end
  def send_log_message(message, type: nil); end
  def send_message(message); end
  def shutdown; end
  def start; end
end
module URI
end
class URI::Generic
  def add_require_path_from_load_entry(load_path_entry); end
  def full_path; end
  def require_path; end
  def require_path=(arg0); end
  def self.from_path(path:, fragment: nil, scheme: nil, load_path_entry: nil); end
  def to_standardized_path; end
end
module RubyIndexer
end
class RubyIndexer::VisibilityScope
  def initialize(visibility: nil, module_func: nil); end
  def module_func; end
  def self.module_function_scope; end
  def self.public_scope; end
  def visibility; end
end
class RubyIndexer::DeclarationListener
  def add_class(name_or_nesting, full_location, name_location, parent_class_name: nil, comments: nil); end
  def add_constant(node, name, value = nil); end
  def add_method(name, node_location, signatures, visibility: nil, comments: nil); end
  def add_module(name, full_location, name_location, comments: nil); end
  def advance_namespace_stack(short_name, entry); end
  def collect_comments(node); end
  def comment_exists_at?(line); end
  def current_owner; end
  def current_visibility_scope; end
  def fully_qualify_name(name); end
  def handle_alias_method(node); end
  def handle_attribute(node, reader:, writer:); end
  def handle_class_variable(node, loc); end
  def handle_global_variable(node, loc); end
  def handle_instance_variable(node, loc); end
  def handle_module_function(node); end
  def handle_module_operation(node, operation); end
  def handle_private_class_method(node); end
  def handle_private_constant(node); end
  def handle_visibility_change(node, visibility); end
  def indexing_errors; end
  def initialize(index, dispatcher, parse_result, uri, collect_comments: nil); end
  def last_name_in_stack; end
  def list_params(parameters_node); end
  def on_alias_method_node_enter(node); end
  def on_call_node_enter(node); end
  def on_call_node_leave(node); end
  def on_class_node_enter(node); end
  def on_class_node_leave(node); end
  def on_class_variable_and_write_node_enter(node); end
  def on_class_variable_operator_write_node_enter(node); end
  def on_class_variable_or_write_node_enter(node); end
  def on_class_variable_target_node_enter(node); end
  def on_class_variable_write_node_enter(node); end
  def on_constant_and_write_node_enter(node); end
  def on_constant_operator_write_node_enter(node); end
  def on_constant_or_write_node_enter(node); end
  def on_constant_path_and_write_node_enter(node); end
  def on_constant_path_operator_write_node_enter(node); end
  def on_constant_path_or_write_node_enter(node); end
  def on_constant_path_write_node_enter(node); end
  def on_constant_write_node_enter(node); end
  def on_def_node_enter(node); end
  def on_def_node_leave(node); end
  def on_global_variable_and_write_node_enter(node); end
  def on_global_variable_operator_write_node_enter(node); end
  def on_global_variable_or_write_node_enter(node); end
  def on_global_variable_target_node_enter(node); end
  def on_global_variable_write_node_enter(node); end
  def on_instance_variable_and_write_node_enter(node); end
  def on_instance_variable_operator_write_node_enter(node); end
  def on_instance_variable_or_write_node_enter(node); end
  def on_instance_variable_target_node_enter(node); end
  def on_instance_variable_write_node_enter(node); end
  def on_module_node_enter(node); end
  def on_module_node_leave(node); end
  def on_multi_write_node_enter(node); end
  def on_singleton_class_node_enter(node); end
  def on_singleton_class_node_leave(node); end
  def parameter_name(node); end
  def pop_namespace_stack; end
  def register_included_hook(&block); end
  def string_or_symbol_argument_values(node); end
end
class RubyIndexer::ReferenceFinder
  def collect_constant_references(name, location); end
  def collect_instance_variable_references(name, location, declaration); end
  def initialize(target, index, dispatcher, uri, include_declarations: nil); end
  def on_call_node_enter(node); end
  def on_class_node_enter(node); end
  def on_class_node_leave(node); end
  def on_constant_and_write_node_enter(node); end
  def on_constant_operator_write_node_enter(node); end
  def on_constant_or_write_node_enter(node); end
  def on_constant_path_and_write_node_enter(node); end
  def on_constant_path_node_enter(node); end
  def on_constant_path_operator_write_node_enter(node); end
  def on_constant_path_or_write_node_enter(node); end
  def on_constant_path_write_node_enter(node); end
  def on_constant_read_node_enter(node); end
  def on_constant_write_node_enter(node); end
  def on_def_node_enter(node); end
  def on_def_node_leave(node); end
  def on_instance_variable_and_write_node_enter(node); end
  def on_instance_variable_operator_write_node_enter(node); end
  def on_instance_variable_or_write_node_enter(node); end
  def on_instance_variable_read_node_enter(node); end
  def on_instance_variable_target_node_enter(node); end
  def on_instance_variable_write_node_enter(node); end
  def on_module_node_enter(node); end
  def on_module_node_leave(node); end
  def on_multi_write_node_enter(node); end
  def on_singleton_class_node_enter(node); end
  def on_singleton_class_node_leave(node); end
  def references; end
end
class RubyIndexer::ReferenceFinder::Target
end
class RubyIndexer::ReferenceFinder::ConstTarget < RubyIndexer::ReferenceFinder::Target
  def fully_qualified_name; end
  def initialize(fully_qualified_name); end
end
class RubyIndexer::ReferenceFinder::MethodTarget < RubyIndexer::ReferenceFinder::Target
  def initialize(method_name); end
  def method_name; end
end
class RubyIndexer::ReferenceFinder::InstanceVariableTarget < RubyIndexer::ReferenceFinder::Target
  def initialize(name, owner_ancestors); end
  def name; end
  def owner_ancestors; end
end
class RubyIndexer::ReferenceFinder::Reference
  def declaration; end
  def initialize(name, location, declaration:); end
  def location; end
  def name; end
end
class RubyIndexer::Enhancement
  def initialize(listener); end
  def on_call_node_enter(node); end
  def on_call_node_leave(node); end
  def self.all(listener); end
  def self.clear; end
  def self.inherited(child); end
end
class RubyIndexer::Index
  def [](fully_qualified_name); end
  def add(entry, skip_prefix_tree: nil); end
  def build_non_redundant_full_name(name, nesting); end
  def class_variable_completion_candidates(name, owner_name); end
  def clear_ancestors; end
  def configuration; end
  def constant_completion_candidates(name, nesting); end
  def delete(uri, skip_require_paths_tree: nil); end
  def direct_or_aliased_constant(full_name, seen_names); end
  def empty?; end
  def entries_for(uri, type = nil); end
  def existing_or_new_singleton_class(name); end
  def first_unqualified_const(name); end
  def follow_aliased_namespace(name, seen_names = nil); end
  def fuzzy_search(query); end
  def handle_change(uri, source = nil, &block); end
  def index_all(uris: nil, &block); end
  def index_file(uri, collect_comments: nil); end
  def index_single(uri, source, collect_comments: nil); end
  def indexed?(name); end
  def inherited_constant_completion_candidates(name, nesting); end
  def initial_indexing_completed; end
  def initialize; end
  def instance_variable_completion_candidates(name, owner_name); end
  def length; end
  def linearize_mixins(ancestors, namespace_entries, nesting); end
  def linearize_superclass(ancestors, attached_class_name, fully_qualified_name, namespace_entries, nesting, singleton_levels); end
  def linearized_ancestors_of(fully_qualified_name); end
  def linearized_attached_ancestors(name); end
  def lookup_ancestor_chain(name, nesting, seen_names); end
  def lookup_enclosing_scopes(name, nesting, seen_names); end
  def method_completion_candidates(name, receiver_name); end
  def names; end
  def prefix_search(query, nesting = nil); end
  def register_included_hook(module_name, &hook); end
  def resolve(name, nesting, seen_names = nil); end
  def resolve_alias(entry, seen_names); end
  def resolve_class_variable(variable_name, owner_name); end
  def resolve_instance_variable(variable_name, owner_name); end
  def resolve_method(method_name, receiver_name, seen_names = nil, inherited_only: nil); end
  def resolve_method_alias(entry, receiver_name, seen_names); end
  def run_included_hooks(fully_qualified_name, nesting); end
  def search_require_paths(query); end
  def self.actual_nesting(stack, name); end
  def self.constant_name(node); end
end
class RubyIndexer::Index::UnresolvableAliasError < StandardError
end
class RubyIndexer::Index::NonExistingNamespaceError < StandardError
end
class RubyIndexer::Index::IndexNotEmptyError < StandardError
end
class RubyIndexer::Entry
  def comments; end
  def file_name; end
  def file_path; end
  def initialize(name, uri, location, comments); end
  def location; end
  def name; end
  def name_location; end
  def private?; end
  def protected?; end
  def public?; end
  def uri; end
  def visibility; end
  def visibility=(arg0); end
end
class RubyIndexer::Entry::ModuleOperation
  def initialize(module_name); end
  def module_name; end
end
class RubyIndexer::Entry::Include < RubyIndexer::Entry::ModuleOperation
end
class RubyIndexer::Entry::Prepend < RubyIndexer::Entry::ModuleOperation
end
class RubyIndexer::Entry::Namespace < RubyIndexer::Entry
  def ancestor_hash; end
  def initialize(nesting, uri, location, name_location, comments); end
  def mixin_operation_module_names; end
  def mixin_operations; end
  def name_location; end
  def nesting; end
end
class RubyIndexer::Entry::Module < RubyIndexer::Entry::Namespace
end
class RubyIndexer::Entry::Class < RubyIndexer::Entry::Namespace
  def ancestor_hash; end
  def initialize(nesting, uri, location, name_location, comments, parent_class); end
  def parent_class; end
end
class RubyIndexer::Entry::SingletonClass < RubyIndexer::Entry::Class
  def update_singleton_information(location, name_location, comments); end
end
class RubyIndexer::Entry::Constant < RubyIndexer::Entry
end
class RubyIndexer::Entry::Parameter
  def decorated_name; end
  def initialize(name:); end
  def name; end
end
class RubyIndexer::Entry::RequiredParameter < RubyIndexer::Entry::Parameter
end
class RubyIndexer::Entry::OptionalParameter < RubyIndexer::Entry::Parameter
  def decorated_name; end
end
class RubyIndexer::Entry::KeywordParameter < RubyIndexer::Entry::Parameter
  def decorated_name; end
end
class RubyIndexer::Entry::OptionalKeywordParameter < RubyIndexer::Entry::Parameter
  def decorated_name; end
end
class RubyIndexer::Entry::RestParameter < RubyIndexer::Entry::Parameter
  def decorated_name; end
end
class RubyIndexer::Entry::KeywordRestParameter < RubyIndexer::Entry::Parameter
  def decorated_name; end
end
class RubyIndexer::Entry::BlockParameter < RubyIndexer::Entry::Parameter
  def decorated_name; end
  def self.anonymous; end
end
class RubyIndexer::Entry::ForwardingParameter < RubyIndexer::Entry::Parameter
  def initialize; end
end
class RubyIndexer::Entry::Member < RubyIndexer::Entry
  def decorated_parameters; end
  def formatted_signatures; end
  def initialize(name, uri, location, comments, visibility, owner); end
  def owner; end
  def signatures; end
end
class RubyIndexer::Entry::Accessor < RubyIndexer::Entry::Member
  def signatures; end
end
class RubyIndexer::Entry::Method < RubyIndexer::Entry::Member
  def initialize(name, uri, location, name_location, comments, signatures, visibility, owner); end
  def name_location; end
  def signatures; end
end
class RubyIndexer::Entry::UnresolvedConstantAlias < RubyIndexer::Entry
  def initialize(target, nesting, name, uri, location, comments); end
  def nesting; end
  def target; end
end
class RubyIndexer::Entry::ConstantAlias < RubyIndexer::Entry
  def initialize(target, unresolved_alias); end
  def target; end
end
class RubyIndexer::Entry::GlobalVariable < RubyIndexer::Entry
end
class RubyIndexer::Entry::ClassVariable < RubyIndexer::Entry
  def initialize(name, uri, location, comments, owner); end
  def owner; end
end
class RubyIndexer::Entry::InstanceVariable < RubyIndexer::Entry
  def initialize(name, uri, location, comments, owner); end
  def owner; end
end
class RubyIndexer::Entry::UnresolvedMethodAlias < RubyIndexer::Entry
  def initialize(new_name, old_name, owner, uri, location, comments); end
  def new_name; end
  def old_name; end
  def owner; end
end
class RubyIndexer::Entry::MethodAlias < RubyIndexer::Entry
  def decorated_parameters; end
  def formatted_signatures; end
  def initialize(target, unresolved_alias); end
  def owner; end
  def signatures; end
  def target; end
end
class RubyIndexer::Entry::Signature
  def format; end
  def initialize(parameters); end
  def keyword_arguments_match?(args, names); end
  def matches?(arguments); end
  def parameters; end
  def positional_arguments_match?(positional_args, forwarding_arguments, keyword_args, min_pos, max_pos); end
end
class RubyIndexer::Configuration
  def apply_config(config); end
  def encoding; end
  def encoding=(arg0); end
  def indexable_uris; end
  def initial_excluded_gems; end
  def initialize; end
  def magic_comment_regex; end
  def test_files_ignored_from_exclusion?(path, bundle_path); end
  def top_level_directories; end
  def validate_config!(config); end
  def workspace_path=(arg0); end
end
class RubyIndexer::PrefixTree
  def delete(key); end
  def find_node(key); end
  def initialize; end
  def insert(key, value); end
  def search(prefix); end
end
class RubyIndexer::PrefixTree::Node
  def children; end
  def collect; end
  def initialize(key, value, parent = nil); end
  def key; end
  def leaf; end
  def leaf=(arg0); end
  def parent; end
  def value; end
  def value=(arg0); end
end
class RubyIndexer::Location
  def ==(other); end
  def end_column; end
  def end_line; end
  def initialize(start_line, end_line, start_column, end_column); end
  def self.from_prism_location(prism_location, code_units_cache); end
  def start_column; end
  def start_line; end
end
class RubyIndexer::RBSIndexer
  def add_declaration_mixins_to_entry(declaration, entry); end
  def comments_to_string(declaration); end
  def handle_class_or_module_declaration(declaration, pathname); end
  def handle_constant(declaration, nesting, uri); end
  def handle_global_variable(declaration, pathname); end
  def handle_method(member, owner); end
  def handle_signature_alias(member, owner_entry); end
  def index_ruby_core; end
  def initialize(index); end
  def parse_arguments(function); end
  def process_declaration(declaration, pathname); end
  def process_optional_keywords(function); end
  def process_overload(overload); end
  def process_required_and_optional_positionals(function); end
  def process_required_keywords(function); end
  def process_rest_keywords(function); end
  def process_rest_positionals(function); end
  def process_signature(pathname, declarations); end
  def process_trailing_positionals(function); end
  def signatures(member); end
  def to_ruby_indexer_location(rbs_location); end
end
class RubyLsp::DelegateRequestError < StandardError
end
class RubyLsp::Message
  def initialize(method:, params:); end
  def method; end
  def params; end
  def to_hash; end
end
class RubyLsp::Notification < RubyLsp::Message
  def self.progress_begin(id, title, percentage: nil, message: nil); end
  def self.progress_end(id); end
  def self.progress_report(id, percentage: nil, message: nil); end
  def self.publish_diagnostics(uri, diagnostics, version: nil); end
  def self.telemetry(data); end
  def self.window_log_message(message, type: nil); end
  def self.window_show_message(message, type: nil); end
  def to_hash; end
end
class RubyLsp::Request < RubyLsp::Message
  def initialize(id:, method:, params:); end
  def self.register_watched_files(id, pattern, kind: nil, registration_id: nil); end
  def to_hash; end
end
class RubyLsp::Error
  def code; end
  def initialize(id:, code:, message:, data: nil); end
  def message; end
  def to_hash; end
end
class RubyLsp::Result
  def id; end
  def initialize(id:, response:); end
  def response; end
  def to_hash; end
end
class RubyLsp::RequestConfig
  def configuration; end
  def configuration=(arg0); end
  def enabled?(feature); end
  def initialize(configuration); end
end
class RubyLsp::SorbetLevel
  def false?; end
  def ignore?; end
  def initialize(sigil); end
  def none?; end
  def self.ignore; end
  def strict?; end
  def true?; end
  def true_or_higher?; end
end
class RubyLsp::Scope
  def add(name, type); end
  def initialize(parent = nil); end
  def lookup(name); end
  def parent; end
end
class RubyLsp::Scope::Local
  def initialize(type); end
  def type; end
end
class RubyLsp::ClientCapabilities
  def apply_client_capabilities(capabilities); end
  def initialize; end
  def supports_code_lens_refresh; end
  def supports_diagnostic_refresh; end
  def supports_progress; end
  def supports_rename?; end
  def supports_request_delegation; end
  def supports_watching_files; end
  def window_show_message_supports_extra_properties; end
end
class RubyLsp::GlobalState
  def active_formatter; end
  def active_linters; end
  def apply_options(options); end
  def bin_rails_present; end
  def client_capabilities; end
  def detect_formatter(direct_dependencies, all_dependencies); end
  def detect_linters(dependencies, all_dependencies); end
  def detect_test_library(dependencies); end
  def detect_typechecker(dependencies); end
  def dot_rubocop_yml_present; end
  def enabled_feature?(flag); end
  def encoding; end
  def encoding_name; end
  def formatter; end
  def formatter=(arg0); end
  def gather_direct_and_indirect_dependencies; end
  def gather_direct_dependencies; end
  def gemspec_dependencies; end
  def has_type_checker; end
  def index; end
  def initialize; end
  def register_formatter(identifier, instance); end
  def settings_for_addon(addon_name); end
  def supports_watching_files; end
  def synchronize(&block); end
  def telemetry_machine_id; end
  def test_library; end
  def top_level_bundle; end
  def type_inferrer; end
  def workspace_path; end
  def workspace_uri; end
end
class RubyLsp::Server < RubyLsp::BaseServer
  def begin_progress(id, title, percentage: nil); end
  def check_formatter_is_available; end
  def code_action_resolve(message); end
  def code_lens_resolve(message); end
  def compose_bundle(message); end
  def diagnose_state(message); end
  def discover_tests(message); end
  def end_progress(id); end
  def experimental_go_to_relevant_file(message); end
  def global_state; end
  def handle_rubocop_config_change(uri); end
  def handle_ruby_file_change(index, file_path, change_type); end
  def load_addons(include_project_addons: nil); end
  def perform_initial_indexing; end
  def process_indexing_configuration(indexing_options); end
  def process_message(message); end
  def process_response(message); end
  def progress(id, percentage); end
  def resolve_test_commands(message); end
  def run_combined_requests(message); end
  def run_initialize(message); end
  def run_initialized; end
  def shutdown; end
  def sorbet_level(document); end
  def text_document_code_action(message); end
  def text_document_code_lens(message); end
  def text_document_completion(message); end
  def text_document_completion_item_resolve(message); end
  def text_document_definition(message); end
  def text_document_diagnostic(message); end
  def text_document_did_change(message); end
  def text_document_did_close(message); end
  def text_document_did_open(message); end
  def text_document_document_highlight(message); end
  def text_document_document_link(message); end
  def text_document_document_symbol(message); end
  def text_document_folding_range(message); end
  def text_document_formatting(message); end
  def text_document_hover(message); end
  def text_document_inlay_hint(message); end
  def text_document_on_type_formatting(message); end
  def text_document_prepare_rename(message); end
  def text_document_prepare_type_hierarchy(message); end
  def text_document_range_formatting(message); end
  def text_document_references(message); end
  def text_document_rename(message); end
  def text_document_selection_range(message); end
  def text_document_semantic_tokens_delta(message); end
  def text_document_semantic_tokens_full(message); end
  def text_document_semantic_tokens_range(message); end
  def text_document_show_syntax_tree(message); end
  def text_document_signature_help(message); end
  def type_hierarchy_subtypes(message); end
  def type_hierarchy_supertypes(message); end
  def window_show_message_request(message); end
  def workspace_dependencies(message); end
  def workspace_did_change_watched_files(message); end
  def workspace_symbol(message); end
end
class RubyLsp::TypeInferrer
  def guess_type(raw_receiver, nesting); end
  def infer_receiver_for_call_node(node, node_context); end
  def infer_receiver_for_class_variables(node_context); end
  def infer_receiver_type(node_context); end
  def initialize(index); end
  def self_receiver_handling(node_context); end
end
class RubyLsp::TypeInferrer::Type
  def attached; end
  def initialize(name); end
  def name; end
end
class RubyLsp::TypeInferrer::GuessedType < RubyLsp::TypeInferrer::Type
end
class RubyLsp::NodeContext
  def call_node; end
  def fully_qualified_name; end
  def handle_nesting_nodes(nodes); end
  def initialize(node, parent, nesting_nodes, call_node); end
  def locals_for_scope; end
  def nesting; end
  def node; end
  def parent; end
  def surrounding_method; end
end
class RubyLsp::Document
  def ==(other); end
  def cache_fetch(request_name, &block); end
  def cache_get(request_name); end
  def cache_set(request_name, value); end
  def clear_cache(request_name); end
  def create_scanner; end
  def encoding; end
  def find_index_by_position(start_pos, end_pos = nil); end
  def initialize(source:, version:, uri:, global_state:); end
  def language_id; end
  def last_edit; end
  def parse!; end
  def parse_result; end
  def past_expensive_limit?; end
  def push_edits(edits, version:); end
  def semantic_tokens; end
  def semantic_tokens=(arg0); end
  def source; end
  def syntax_error?; end
  def uri; end
  def version; end
  extend T::Generic
end
class RubyLsp::Document::LocationNotFoundError < StandardError
end
class RubyLsp::Document::Edit
  def initialize(range); end
  def range; end
end
class RubyLsp::Document::Insert < RubyLsp::Document::Edit
end
class RubyLsp::Document::Replace < RubyLsp::Document::Edit
end
class RubyLsp::Document::Delete < RubyLsp::Document::Edit
end
class RubyLsp::Document::Scanner
  def find_char_position(position); end
  def initialize(source, encoding); end
  def utf_16_character_position_correction(current_position, requested_position); end
  extend T::Sig
end
class RubyLsp::RubyDocument < RubyLsp::Document
  def code_units_cache; end
  def initialize(source:, version:, uri:, global_state:); end
  def language_id; end
  def last_edit_may_change_declarations?; end
  def locate_first_within_range(range, node_types: nil); end
  def locate_node(position, node_types: nil); end
  def parse!; end
  def position_may_impact_declarations?(position); end
  def self.locate(node, char_position, code_units_cache:, node_types: nil); end
  def should_index?; end
  def syntax_error?; end
end
class RubyLsp::ERBDocument < RubyLsp::Document
  def code_units_cache; end
  def host_language_source; end
  def initialize(source:, version:, uri:, global_state:); end
  def inside_host_language?(char_position); end
  def language_id; end
  def locate_node(position, node_types: nil); end
  def parse!; end
  def syntax_error?; end
end
class RubyLsp::ERBDocument::ERBScanner
  def host_language; end
  def initialize(source); end
  def next_char; end
  def push_char(char); end
  def ruby; end
  def scan; end
  def scan_char; end
end
class RubyLsp::RBSDocument < RubyLsp::Document
  def initialize(source:, version:, uri:, global_state:); end
  def language_id; end
  def parse!; end
  def syntax_error?; end
end
class RubyLsp::Store
  def cache_fetch(uri, request_name, &block); end
  def clear; end
  def client_name; end
  def client_name=(arg0); end
  def delete(uri); end
  def each(&block); end
  def empty?; end
  def features_configuration; end
  def features_configuration=(arg0); end
  def get(uri); end
  def initialize(global_state); end
  def key?(uri); end
  def push_edits(uri:, edits:, version:); end
  def set(uri:, source:, version:, language_id:); end
end
class RubyLsp::Store::NonExistingDocumentError < StandardError
end
module RubyLsp::ResponseBuilders
end
class RubyLsp::ResponseBuilders::ResponseBuilder
  def response; end
  extend T::Generic
end
class RubyLsp::ResponseBuilders::CollectionResponseBuilder < RubyLsp::ResponseBuilders::ResponseBuilder
  def <<(item); end
  def initialize; end
  def response; end
end
class RubyLsp::ResponseBuilders::DocumentSymbol < RubyLsp::ResponseBuilders::ResponseBuilder
  def <<(symbol); end
  def initialize; end
  def last; end
  def pop; end
  def push(symbol); end
  def response; end
end
class RubyLsp::ResponseBuilders::DocumentSymbol::SymbolHierarchyRoot
  def children; end
  def initialize; end
end
class RubyLsp::ResponseBuilders::Hover < RubyLsp::ResponseBuilders::ResponseBuilder
  def empty?; end
  def initialize; end
  def push(content, category:); end
  def response; end
end
class RubyLsp::ResponseBuilders::SemanticHighlighting < RubyLsp::ResponseBuilders::ResponseBuilder
  def add_token(location, type, modifiers = nil); end
  def initialize(code_units_cache); end
  def last; end
  def last_token_matches?(location); end
  def response; end
end
class RubyLsp::ResponseBuilders::SemanticHighlighting::UndefinedTokenType < StandardError
end
class RubyLsp::ResponseBuilders::SemanticHighlighting::SemanticToken
  def initialize(start_line:, start_code_unit_column:, length:, type:, modifier:); end
  def length; end
  def modifier; end
  def replace_modifier(modifier_symbols); end
  def replace_type(type_symbol); end
  def start_code_unit_column; end
  def start_line; end
  def type; end
end
class RubyLsp::ResponseBuilders::SemanticHighlighting::SemanticTokenEncoder
  def compute_delta(token); end
  def encode(tokens); end
  def encode_modifiers(modifiers); end
  def initialize; end
end
class RubyLsp::ResponseBuilders::SignatureHelp < RubyLsp::ResponseBuilders::ResponseBuilder
  def initialize; end
  def replace(signature_help); end
  def response; end
end
class RubyLsp::ResponseBuilders::TestCollection < RubyLsp::ResponseBuilders::ResponseBuilder
  def [](id); end
  def add(item); end
  def add_code_lens(item); end
  def code_lens; end
  def initialize; end
  def response; end
end
module RubyLsp::Requests
end
module RubyLsp::Requests::Support
end
class RubyLsp::Requests::Support::SelectionRange < LanguageServer::Protocol::Interface::SelectionRange
  def cover?(position); end
end
class RubyLsp::Requests::Support::Annotation
  def arity_matches?(node); end
  def initialize(arity:, receiver: nil); end
  def match?(node); end
  def receiver_matches?(node); end
end
class RubyLsp::Requests::Support::Sorbet
  def self.annotation?(node); end
end
module RubyLsp::Requests::Support::Common
  def categorized_markdown_from_index_entries(title, entries, max_entries = nil); end
  def constant_name(node); end
  def create_code_lens(node, title:, command_name:, arguments:, data:); end
  def each_constant_path_part(node, &block); end
  def kind_for_entry(entry); end
  def markdown_from_index_entries(title, entries, max_entries = nil, extra_links: nil); end
  def namespace_constant_name(node); end
  def not_in_dependencies?(file_path); end
  def range_from_location(location); end
  def range_from_node(node); end
  def self_receiver?(node); end
end
module RubyLsp::Requests::Support::Formatter
  def run_diagnostic(uri, document); end
  def run_formatting(uri, document); end
  def run_range_formatting(uri, source, base_indentation); end
end
class RubyLsp::Requests::Support::InternalRuboCopError < StandardError
  def initialize(rubocop_error); end
end
class RubyLsp::Requests::Support::RuboCopRunner < RuboCop::Runner
  def config_for_working_directory; end
  def file_finished(_file, offenses); end
  def formatted_source; end
  def initialize(*args); end
  def offenses; end
  def run(path, contents); end
  def self.cop_registry; end
  def self.find_cop_by_name(cop_name); end
end
class RubyLsp::Requests::Support::RuboCopRunner::ConfigurationError < StandardError
end
class RubyLsp::Requests::Support::RuboCopDiagnostic
  def autocorrect_action; end
  def code_description(config); end
  def correctable?; end
  def disable_line_action; end
  def initialize(document, offense, uri); end
  def length_of_line(line); end
  def line_disable_comment; end
  def message; end
  def offense_replacements; end
  def severity; end
  def to_lsp_code_actions; end
  def to_lsp_diagnostic(config); end
end
class RubyLsp::Requests::Support::RuboCopFormatter
  def initialize; end
  def run_diagnostic(uri, document); end
  def run_formatting(uri, document); end
  def run_range_formatting(uri, source, base_indentation); end
  include RubyLsp::Requests::Support::Formatter
end
class RubyLsp::Requests::Support::TestItem
  def [](id); end
  def add(item); end
  def children; end
  def id; end
  def initialize(id, label, uri, range, framework:); end
  def label; end
  def range; end
  def to_hash; end
  def uri; end
end
class RubyLsp::Requests::Request
  def cover?(location, position); end
  def covers_position?(location, position); end
  def delegate_request_if_needed!(global_state, document, char_position); end
  def determine_target(target, parent, position); end
  def perform; end
end
class RubyLsp::Requests::Request::InvalidFormatter < StandardError
end
class RubyLsp::Requests::CodeActionResolve < RubyLsp::Requests::Request
  def create_attribute_accessor; end
  def create_text_edit(range, new_text); end
  def initialize(document, global_state, code_action); end
  def perform; end
  def recursively_switch_nested_block_styles(node, indentation); end
  def refactor_method; end
  def refactor_variable; end
  def switch_block_body(body, indentation); end
  def switch_block_style; end
  include RubyLsp::Requests::Support::Common
end
class RubyLsp::Requests::CodeActionResolve::CodeActionError < StandardError
end
class RubyLsp::Requests::CodeActionResolve::EmptySelectionError < RubyLsp::Requests::CodeActionResolve::CodeActionError
end
class RubyLsp::Requests::CodeActionResolve::InvalidTargetRangeError < RubyLsp::Requests::CodeActionResolve::CodeActionError
end
class RubyLsp::Requests::CodeActionResolve::UnknownCodeActionError < RubyLsp::Requests::CodeActionResolve::CodeActionError
end
class RubyLsp::Requests::CodeActions < RubyLsp::Requests::Request
  def attribute_actions; end
  def initialize(document, range, context); end
  def perform; end
  def self.provider; end
end
module RubyLsp::Listeners
end
class RubyLsp::Listeners::CodeLens
  def add_spec_code_lens(node, kind:); end
  def add_test_code_lens(node, name:, command:, kind:, id: nil); end
  def generate_fully_qualified_id(group_stack:, method_name: nil); end
  def generate_minitest_command(group_stack, method_name, spec_name); end
  def generate_test_command(group_stack: nil, spec_name: nil, method_name: nil); end
  def generate_test_unit_command(group_stack, method_name); end
  def initialize(response_builder, global_state, uri, dispatcher); end
  def on_call_node_enter(node); end
  def on_call_node_leave(node); end
  def on_class_node_enter(node); end
  def on_class_node_leave(node); end
  def on_def_node_enter(node); end
  def on_def_node_leave(node); end
  def on_module_node_enter(node); end
  def on_module_node_leave(node); end
  include RubyLsp::Requests::Support::Common
end
class RubyLsp::Requests::CodeLens < RubyLsp::Requests::Request
  def initialize(global_state, document, dispatcher); end
  def perform; end
  def self.provider; end
end
class RubyLsp::Requests::CompletionResolve < RubyLsp::Requests::Request
  def initialize(global_state, item); end
  def keyword_resolve(item); end
  def perform; end
  include RubyLsp::Requests::Support::Common
end
class RubyLsp::Listeners::Completion
  def add_keyword_completions(node, name); end
  def add_local_completions(node, name); end
  def build_completion(label, node); end
  def build_entry_completion(real_name, incomplete_name, range, entries, top_level); end
  def complete_methods(node, name); end
  def complete_require(node); end
  def complete_require_relative(node); end
  def constant_path_completion(name, range); end
  def handle_class_variable_completion(name, location); end
  def handle_global_variable_completion(name, location); end
  def handle_instance_variable_completion(name, location); end
  def initialize(response_builder, global_state, node_context, sorbet_level, dispatcher, uri, trigger_character); end
  def on_call_node_enter(node); end
  def on_class_variable_and_write_node_enter(node); end
  def on_class_variable_operator_write_node_enter(node); end
  def on_class_variable_or_write_node_enter(node); end
  def on_class_variable_read_node_enter(node); end
  def on_class_variable_target_node_enter(node); end
  def on_class_variable_write_node_enter(node); end
  def on_constant_path_node_enter(node); end
  def on_constant_read_node_enter(node); end
  def on_global_variable_and_write_node_enter(node); end
  def on_global_variable_operator_write_node_enter(node); end
  def on_global_variable_or_write_node_enter(node); end
  def on_global_variable_read_node_enter(node); end
  def on_global_variable_target_node_enter(node); end
  def on_global_variable_write_node_enter(node); end
  def on_instance_variable_and_write_node_enter(node); end
  def on_instance_variable_operator_write_node_enter(node); end
  def on_instance_variable_or_write_node_enter(node); end
  def on_instance_variable_read_node_enter(node); end
  def on_instance_variable_target_node_enter(node); end
  def on_instance_variable_write_node_enter(node); end
  def top_level?(entry_name); end
  include RubyLsp::Requests::Support::Common
end
class RubyLsp::Requests::Completion < RubyLsp::Requests::Request
  def initialize(document, global_state, params, sorbet_level, dispatcher); end
  def perform; end
  def self.provider; end
end
class RubyLsp::Listeners::Definition
  def find_in_index(value); end
  def handle_autoload_definition(node); end
  def handle_class_variable_definition(name); end
  def handle_global_variable_definition(name); end
  def handle_instance_variable_definition(name); end
  def handle_method_definition(message, receiver_type, inherited_only: nil); end
  def handle_require_definition(node, message); end
  def handle_super_node_definition; end
  def initialize(response_builder, global_state, language_id, uri, node_context, dispatcher, sorbet_level); end
  def on_block_argument_node_enter(node); end
  def on_call_node_enter(node); end
  def on_class_variable_and_write_node_enter(node); end
  def on_class_variable_operator_write_node_enter(node); end
  def on_class_variable_or_write_node_enter(node); end
  def on_class_variable_read_node_enter(node); end
  def on_class_variable_target_node_enter(node); end
  def on_class_variable_write_node_enter(node); end
  def on_constant_path_node_enter(node); end
  def on_constant_read_node_enter(node); end
  def on_forwarding_super_node_enter(node); end
  def on_global_variable_and_write_node_enter(node); end
  def on_global_variable_operator_write_node_enter(node); end
  def on_global_variable_or_write_node_enter(node); end
  def on_global_variable_read_node_enter(node); end
  def on_global_variable_target_node_enter(node); end
  def on_global_variable_write_node_enter(node); end
  def on_instance_variable_and_write_node_enter(node); end
  def on_instance_variable_operator_write_node_enter(node); end
  def on_instance_variable_or_write_node_enter(node); end
  def on_instance_variable_read_node_enter(node); end
  def on_instance_variable_target_node_enter(node); end
  def on_instance_variable_write_node_enter(node); end
  def on_string_node_enter(node); end
  def on_super_node_enter(node); end
  def on_symbol_node_enter(node); end
  include RubyLsp::Requests::Support::Common
end
class RubyLsp::Requests::Definition < RubyLsp::Requests::Request
  def initialize(document, global_state, position, dispatcher, sorbet_level); end
  def perform; end
  def position_outside_target?(position, target); end
end
class RubyLsp::Requests::Diagnostics < RubyLsp::Requests::Request
  def initialize(global_state, document); end
  def perform; end
  def self.provider; end
  def syntax_error_diagnostics; end
  def syntax_warning_diagnostics; end
end
class RubyLsp::Listeners::TestDiscovery
  def calc_attached_ancestors(node, fully_qualified_name); end
  def calc_fully_qualified_name(name); end
  def initialize(response_builder, global_state, dispatcher, uri); end
  def name_with_dynamic_reference(node); end
  def on_class_node_leave(node); end
  def on_module_node_enter(node); end
  def on_module_node_leave(node); end
  def with_test_ancestor_tracking(node, &block); end
  include RubyLsp::Requests::Support::Common
end
class RubyLsp::Listeners::TestStyle < RubyLsp::Listeners::TestDiscovery
  def initialize(response_builder, global_state, dispatcher, uri); end
  def last_test_group; end
  def non_declarative_minitest?(attached_ancestors, fully_qualified_name); end
  def on_call_node_enter(node); end
  def on_call_node_leave(node); end
  def on_class_node_enter(node); end
  def on_class_node_leave(node); end
  def on_def_node_enter(node); end
  def on_module_node_enter(node); end
  def on_module_node_leave(node); end
  def self.handle_minitest_groups(file_path, groups_and_examples); end
  def self.handle_test_unit_groups(file_path, groups_and_examples); end
  def self.resolve_test_commands(items); end
  def self.spec?(path); end
  include RubyLsp::Requests::Support::Common
end
class RubyLsp::Listeners::SpecStyle < RubyLsp::Listeners::TestDiscovery
  def extract_description(node); end
  def handle_describe(node); end
  def handle_example(node); end
  def in_spec_context?; end
  def initialize(response_builder, global_state, dispatcher, uri); end
  def latest_group; end
  def on_call_node_enter(node); end
  def on_call_node_leave(node); end
  def on_class_node_enter(node); end
  def on_class_node_leave(node); end
  def on_module_node_enter(node); end
  def on_module_node_leave(node); end
end
class RubyLsp::Listeners::SpecStyle::Group
  def id; end
  def initialize(id); end
end
class RubyLsp::Listeners::SpecStyle::ClassGroup < RubyLsp::Listeners::SpecStyle::Group
end
class RubyLsp::Listeners::SpecStyle::DescribeGroup < RubyLsp::Listeners::SpecStyle::Group
end
class RubyLsp::Requests::DiscoverTests < RubyLsp::Requests::Request
  def initialize(global_state, document, dispatcher); end
  def perform; end
  include RubyLsp::Requests::Support::Common
end
class RubyLsp::Listeners::DocumentHighlight
  def add_highlight(kind, location); end
  def add_matching_end_highlights(keyword_loc, end_loc); end
  def covers_target_position?(location); end
  def initialize(response_builder, target, parent, dispatcher, position); end
  def matches?(node, classes); end
  def node_value(node); end
  def on_block_parameter_node_enter(node); end
  def on_call_node_enter(node); end
  def on_case_node_enter(node); end
  def on_class_node_enter(node); end
  def on_class_variable_and_write_node_enter(node); end
  def on_class_variable_operator_write_node_enter(node); end
  def on_class_variable_or_write_node_enter(node); end
  def on_class_variable_read_node_enter(node); end
  def on_class_variable_target_node_enter(node); end
  def on_class_variable_write_node_enter(node); end
  def on_constant_and_write_node_enter(node); end
  def on_constant_operator_write_node_enter(node); end
  def on_constant_or_write_node_enter(node); end
  def on_constant_path_and_write_node_enter(node); end
  def on_constant_path_node_enter(node); end
  def on_constant_path_operator_write_node_enter(node); end
  def on_constant_path_or_write_node_enter(node); end
  def on_constant_path_target_node_enter(node); end
  def on_constant_path_write_node_enter(node); end
  def on_constant_read_node_enter(node); end
  def on_constant_target_node_enter(node); end
  def on_constant_write_node_enter(node); end
  def on_def_node_enter(node); end
  def on_for_node_enter(node); end
  def on_global_variable_and_write_node_enter(node); end
  def on_global_variable_operator_write_node_enter(node); end
  def on_global_variable_or_write_node_enter(node); end
  def on_global_variable_read_node_enter(node); end
  def on_global_variable_target_node_enter(node); end
  def on_global_variable_write_node_enter(node); end
  def on_if_node_enter(node); end
  def on_instance_variable_and_write_node_enter(node); end
  def on_instance_variable_operator_write_node_enter(node); end
  def on_instance_variable_or_write_node_enter(node); end
  def on_instance_variable_read_node_enter(node); end
  def on_instance_variable_target_node_enter(node); end
  def on_instance_variable_write_node_enter(node); end
  def on_keyword_rest_parameter_node_enter(node); end
  def on_local_variable_and_write_node_enter(node); end
  def on_local_variable_operator_write_node_enter(node); end
  def on_local_variable_or_write_node_enter(node); end
  def on_local_variable_read_node_enter(node); end
  def on_local_variable_target_node_enter(node); end
  def on_local_variable_write_node_enter(node); end
  def on_module_node_enter(node); end
  def on_optional_keyword_parameter_node_enter(node); end
  def on_optional_parameter_node_enter(node); end
  def on_required_keyword_parameter_node_enter(node); end
  def on_required_parameter_node_enter(node); end
  def on_rest_parameter_node_enter(node); end
  def on_singleton_class_node_enter(node); end
  def on_unless_node_enter(node); end
  def on_until_node_enter(node); end
  def on_while_node_enter(node); end
  include RubyLsp::Requests::Support::Common
end
class RubyLsp::Requests::DocumentHighlight < RubyLsp::Requests::Request
  def initialize(global_state, document, position, dispatcher); end
  def perform; end
end
class URI::Source < URI::File
  def check_host(v); end
  def gem_name; end
  def gem_version; end
  def line_number; end
  def self.build(gem_name:, gem_version:, path:, line_number:); end
  def set_path(v); end
  def to_s; end
end
class RubyLsp::Listeners::DocumentLink
  def extract_document_link(node); end
  def initialize(response_builder, uri, comments, dispatcher); end
  def on_class_node_enter(node); end
  def on_constant_path_write_node_enter(node); end
  def on_constant_write_node_enter(node); end
  def on_def_node_enter(node); end
  def on_module_node_enter(node); end
  def resolve_version(uri); end
  def self.gem_paths; end
  include RubyLsp::Requests::Support::Common
end
class RubyLsp::Requests::DocumentLink < RubyLsp::Requests::Request
  def initialize(uri, comments, dispatcher); end
  def perform; end
  def self.provider; end
end
class RubyLsp::Listeners::DocumentSymbol
  def create_document_symbol(name:, kind:, range_location:, selection_range_location:); end
  def handle_alias_method(node); end
  def handle_attr_accessor(node); end
  def handle_rake_namespace(node); end
  def handle_rake_task(node); end
  def initialize(response_builder, uri, dispatcher); end
  def on_alias_method_node_enter(node); end
  def on_call_node_enter(node); end
  def on_call_node_leave(node); end
  def on_class_node_enter(node); end
  def on_class_node_leave(node); end
  def on_class_variable_write_node_enter(node); end
  def on_constant_and_write_node_enter(node); end
  def on_constant_operator_write_node_enter(node); end
  def on_constant_or_write_node_enter(node); end
  def on_constant_path_and_write_node_enter(node); end
  def on_constant_path_operator_write_node_enter(node); end
  def on_constant_path_or_write_node_enter(node); end
  def on_constant_path_target_node_enter(node); end
  def on_constant_path_write_node_enter(node); end
  def on_constant_target_node_enter(node); end
  def on_constant_write_node_enter(node); end
  def on_def_node_enter(node); end
  def on_def_node_leave(node); end
  def on_instance_variable_and_write_node_enter(node); end
  def on_instance_variable_operator_write_node_enter(node); end
  def on_instance_variable_or_write_node_enter(node); end
  def on_instance_variable_target_node_enter(node); end
  def on_instance_variable_write_node_enter(node); end
  def on_module_node_enter(node); end
  def on_module_node_leave(node); end
  def on_singleton_class_node_enter(node); end
  def on_singleton_class_node_leave(node); end
  def rake?; end
  include RubyLsp::Requests::Support::Common
end
class RubyLsp::Requests::DocumentSymbol < RubyLsp::Requests::Request
  def initialize(uri, dispatcher); end
  def perform; end
  def self.provider; end
end
class RubyLsp::Listeners::FoldingRanges
  def add_lines_range(start_line, end_line); end
  def add_simple_range(node); end
  def add_statements_range(node); end
  def emit_requires_range; end
  def finalize_response!; end
  def initialize(response_builder, comments, dispatcher); end
  def on_array_node_enter(node); end
  def on_begin_node_enter(node); end
  def on_block_node_enter(node); end
  def on_call_node_enter(node); end
  def on_case_match_node_enter(node); end
  def on_case_node_enter(node); end
  def on_class_node_enter(node); end
  def on_def_node_enter(node); end
  def on_else_node_enter(node); end
  def on_ensure_node_enter(node); end
  def on_for_node_enter(node); end
  def on_hash_node_enter(node); end
  def on_if_node_enter(node); end
  def on_in_node_enter(node); end
  def on_interpolated_string_node_enter(node); end
  def on_lambda_node_enter(node); end
  def on_module_node_enter(node); end
  def on_rescue_node_enter(node); end
  def on_singleton_class_node_enter(node); end
  def on_unless_node_enter(node); end
  def on_until_node_enter(node); end
  def on_when_node_enter(node); end
  def on_while_node_enter(node); end
  def push_comment_ranges; end
  def require?(node); end
  include RubyLsp::Requests::Support::Common
end
class RubyLsp::Requests::FoldingRanges < RubyLsp::Requests::Request
  def initialize(comments, dispatcher); end
  def perform; end
  def self.provider; end
end
class RubyLsp::Requests::Formatting < RubyLsp::Requests::Request
  def initialize(global_state, document); end
  def perform; end
  def self.provider; end
end
class RubyLsp::Requests::Formatting::Error < StandardError
end
class RubyLsp::Requests::GoToRelevantFile < RubyLsp::Requests::Request
  def find_most_similar_with_jaccard(candidates); end
  def find_relevant_paths; end
  def get_dir_parts(path); end
  def initialize(path, workspace_path); end
  def perform; end
  def relevant_filename_pattern; end
end
class RubyLsp::Listeners::Hover
  def generate_gem_hover(node); end
  def generate_heredoc_hover(node); end
  def generate_hover(name, location); end
  def handle_class_variable_hover(name); end
  def handle_global_variable_hover(name); end
  def handle_instance_variable_hover(name); end
  def handle_keyword_documentation(keyword); end
  def handle_method_hover(message, inherited_only: nil); end
  def handle_super_node_hover; end
  def initialize(response_builder, global_state, uri, node_context, dispatcher, sorbet_level); end
  def on_call_node_enter(node); end
  def on_class_variable_and_write_node_enter(node); end
  def on_class_variable_operator_write_node_enter(node); end
  def on_class_variable_or_write_node_enter(node); end
  def on_class_variable_read_node_enter(node); end
  def on_class_variable_target_node_enter(node); end
  def on_class_variable_write_node_enter(node); end
  def on_constant_path_node_enter(node); end
  def on_constant_read_node_enter(node); end
  def on_constant_write_node_enter(node); end
  def on_forwarding_super_node_enter(node); end
  def on_global_variable_and_write_node_enter(node); end
  def on_global_variable_operator_write_node_enter(node); end
  def on_global_variable_or_write_node_enter(node); end
  def on_global_variable_read_node_enter(node); end
  def on_global_variable_target_node_enter(node); end
  def on_global_variable_write_node_enter(node); end
  def on_instance_variable_and_write_node_enter(node); end
  def on_instance_variable_operator_write_node_enter(node); end
  def on_instance_variable_or_write_node_enter(node); end
  def on_instance_variable_read_node_enter(node); end
  def on_instance_variable_target_node_enter(node); end
  def on_instance_variable_write_node_enter(node); end
  def on_interpolated_string_node_enter(node); end
  def on_string_node_enter(node); end
  def on_super_node_enter(node); end
  def on_yield_node_enter(node); end
  include RubyLsp::Requests::Support::Common
end
class RubyLsp::Requests::Hover < RubyLsp::Requests::Request
  def initialize(document, global_state, position, dispatcher, sorbet_level); end
  def perform; end
  def position_outside_target?(position, target); end
  def self.provider; end
  def should_refine_target?(parent, target); end
end
class RubyLsp::Listeners::InlayHints
  def initialize(response_builder, hints_configuration, dispatcher); end
  def on_implicit_node_enter(node); end
  def on_rescue_node_enter(node); end
  include RubyLsp::Requests::Support::Common
end
class RubyLsp::Requests::InlayHints < RubyLsp::Requests::Request
  def initialize(document, hints_configuration, dispatcher); end
  def perform; end
  def self.provider; end
end
class RubyLsp::Requests::OnTypeFormatting < RubyLsp::Requests::Request
  def add_edit_with_text(text, position = nil); end
  def auto_indent_after_end_keyword; end
  def find_indentation(line); end
  def handle_comment_line(spaces); end
  def handle_curly_brace; end
  def handle_heredoc_end(delimiter); end
  def handle_pipe; end
  def handle_statement_end; end
  def initialize(document, position, trigger_character, client_name); end
  def move_cursor_to(line, character); end
  def perform; end
  def self.provider; end
end
class RubyLsp::Requests::PrepareTypeHierarchy < RubyLsp::Requests::Request
  def initialize(document, index, position); end
  def perform; end
  def self.provider; end
  include RubyLsp::Requests::Support::Common
end
class RubyLsp::Requests::PrepareRename < RubyLsp::Requests::Request
  def initialize(document, position); end
  def perform; end
  include RubyLsp::Requests::Support::Common
end
class RubyLsp::Requests::RangeFormatting < RubyLsp::Requests::Request
  def initialize(global_state, document, params); end
  def perform; end
end
class RubyLsp::Requests::References < RubyLsp::Requests::Request
  def collect_references(target, parse_result, uri); end
  def create_reference_target(target_node, node_context); end
  def initialize(global_state, store, document, params); end
  def perform; end
  include RubyLsp::Requests::Support::Common
end
class RubyLsp::Requests::Rename < RubyLsp::Requests::Request
  def adjust_reference_for_edit(name, reference); end
  def collect_changes(target, parse_result, name, uri); end
  def collect_file_renames(fully_qualified_name, document_changes); end
  def collect_text_edits(target, name); end
  def file_from_constant_name(constant_name); end
  def initialize(global_state, store, document, params); end
  def perform; end
  def self.provider; end
  include RubyLsp::Requests::Support::Common
end
class RubyLsp::Requests::Rename::InvalidNameError < StandardError
end
class RubyLsp::Requests::SelectionRanges < RubyLsp::Requests::Request
  def initialize(document); end
  def perform; end
  include RubyLsp::Requests::Support::Common
end
class RubyLsp::Listeners::SemanticHighlighting
  def initialize(dispatcher, response_builder); end
  def on_block_local_variable_node_enter(node); end
  def on_block_node_enter(node); end
  def on_block_node_leave(node); end
  def on_block_parameter_node_enter(node); end
  def on_call_node_enter(node); end
  def on_class_node_enter(node); end
  def on_def_node_enter(node); end
  def on_def_node_leave(node); end
  def on_implicit_node_enter(node); end
  def on_implicit_node_leave(node); end
  def on_keyword_rest_parameter_node_enter(node); end
  def on_local_variable_and_write_node_enter(node); end
  def on_local_variable_operator_write_node_enter(node); end
  def on_local_variable_or_write_node_enter(node); end
  def on_local_variable_read_node_enter(node); end
  def on_local_variable_target_node_enter(node); end
  def on_local_variable_write_node_enter(node); end
  def on_match_write_node_enter(node); end
  def on_match_write_node_leave(node); end
  def on_module_node_enter(node); end
  def on_optional_keyword_parameter_node_enter(node); end
  def on_optional_parameter_node_enter(node); end
  def on_required_keyword_parameter_node_enter(node); end
  def on_required_parameter_node_enter(node); end
  def on_rest_parameter_node_enter(node); end
  def on_self_node_enter(node); end
  def process_regexp_locals(node); end
  def special_method?(method_name); end
  include RubyLsp::Requests::Support::Common
end
class RubyLsp::Requests::SemanticHighlighting < RubyLsp::Requests::Request
  def initialize(global_state, dispatcher, document, previous_result_id, range: nil); end
  def perform; end
  def self.compute_delta(current_tokens, previous_tokens, result_id); end
  def self.next_result_id; end
  def self.provider; end
end
class RubyLsp::Requests::ShowSyntaxTree < RubyLsp::Requests::Request
  def ast_for_range; end
  def initialize(document, range); end
  def perform; end
end
class RubyLsp::Listeners::SignatureHelp
  def determine_active_signature_and_parameter(node, signatures); end
  def generate_signatures(signatures, method_name, methods, title, extra_links); end
  def initialize(response_builder, global_state, node_context, dispatcher, sorbet_level); end
  def on_call_node_enter(node); end
  include RubyLsp::Requests::Support::Common
end
class RubyLsp::Requests::SignatureHelp < RubyLsp::Requests::Request
  def adjust_for_nested_target(target, parent, position); end
  def initialize(document, global_state, position, context, dispatcher, sorbet_level); end
  def node_covers?(node, position); end
  def perform; end
  def self.provider; end
end
class RubyLsp::Requests::TypeHierarchySupertypes < RubyLsp::Requests::Request
  def hierarchy_item(entry); end
  def initialize(index, item); end
  def perform; end
  include RubyLsp::Requests::Support::Common
end
class RubyLsp::Requests::WorkspaceSymbol < RubyLsp::Requests::Request
  def initialize(global_state, query); end
  def perform; end
  include RubyLsp::Requests::Support::Common
end
module RubyLsp::TestHelper
  def pop_log_notification(message_queue, type); end
  def pop_message(outgoing_queue, &block); end
  def pop_result(server); end
  def with_server(source = nil, uri = nil, stub_no_typechecker: nil, load_addons: nil, &block); end
end
class RubyLsp::TestHelper::TestError < StandardError
end
